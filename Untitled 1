import ch.qos.logback.classic.Logger;
import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.encoder.PatternLayoutEncoder;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.FileAppender;
import org.slf4j.LoggerFactory;

public class LogbackDynamicConfig {

    public static Logger createDynamicLogger(String name, String fileName) {
        LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();
        
        // 1. Encoder für das Format erstellen
        PatternLayoutEncoder ple = new PatternLayoutEncoder();
        ple.setPattern("%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n");
        ple.setContext(lc);
        ple.start();

        // 2. FileAppender erstellen
        FileAppender<ILoggingEvent> fileAppender = new FileAppender<>();
        fileAppender.setFile(fileName);
        fileAppender.setEncoder(ple);
        fileAppender.setContext(lc);
        fileAppender.setName("DYNAMIC_FILE_" + name);
        fileAppender.start();

        // 3. Logger holen und Appender zuweisen
        Logger logger = (Logger) LoggerFactory.getLogger(name);
        logger.addAppender(fileAppender);
        
        // Optional: Verhindern, dass Logs an den Root-Logger (Konsole) weitergereicht werden
        logger.setAdditive(false); 
        
        return logger;
    }
}

1. Database Bundle:

Wollen Sie API-Bundle + Implementation trennen? (Best Practice)
Soll H2 im Embedded oder Server-Mode laufen?
Brauchen Sie JPA/Hibernate oder reicht JDBC?
Connection-Pool? (z.B. HikariCP)

/* --------------------------------------------------------------------------
 * Project: CAR OSGi - H2 Console
 * --------------------------------------------------------------------------
 * Starts the H2 Web Console as an OSGi service
 * -------------------------------------------------------------------------- */

package biz.car.osgi.h2.console;

import org.h2.tools.Server;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.ConfigurationPolicy;
import org.osgi.service.component.annotations.Deactivate;
import org.osgi.service.metatype.annotations.AttributeDefinition;
import org.osgi.service.metatype.annotations.Designate;
import org.osgi.service.metatype.annotations.ObjectClassDefinition;

/**
 * OSGi Declarative Service that starts and manages the H2 Web Console.
 * 
 * <p>The H2 Console provides a web-based interface for managing H2 databases.
 * Default URL: http://localhost:8082
 * 
 * @version 1.0.0 25.01.2026 15:00:00
 */
@Component(
    immediate = true,
    configurationPolicy = ConfigurationPolicy.OPTIONAL,
    service = H2ConsoleService.class
)
@Designate(ocd = H2ConsoleService.Config.class)
public class H2ConsoleService {

    @ObjectClassDefinition(
        name = "H2 Web Console Configuration",
        description = "Configuration for the H2 Database Web Console"
    )
    public @interface Config {
        
        @AttributeDefinition(
            name = "Enable Console",
            description = "Enable or disable the H2 Web Console"
        )
        boolean enabled() default true;
        
        @AttributeDefinition(
            name = "Console Port",
            description = "Port number for the H2 Web Console (default: 8082)"
        )
        int port() default 8082;
        
        @AttributeDefinition(
            name = "Allow Remote Access",
            description = "Allow connections from remote hosts (default: false for security)"
        )
        boolean allowOthers() default false;
        
        @AttributeDefinition(
            name = "Enable SSL",
            description = "Use SSL for the web console connection"
        )
        boolean useSSL() default false;
        
        @AttributeDefinition(
            name = "Open Browser",
            description = "Automatically open browser when console starts (disable in server environments)"
        )
        boolean openBrowser() default false;
    }
    
    private Server webServer;
    private Config config;
    
    @Activate
    protected void activate(Config config) throws Exception {
        this.config = config;
        
        if (!config.enabled()) {
            System.out.println("H2 Web Console is disabled");
            return;
        }
        
        // Build H2 Console arguments
        String[] args = buildConsoleArgs(config);
        
        // Start the H2 Web Console server
        webServer = Server.createWebServer(args);
        webServer.start();
        
        String url = webServer.getURL();
        System.out.println("========================================");
        System.out.println("H2 Web Console started");
        System.out.println("URL: " + url);
        System.out.println("Port: " + config.port());
        System.out.println("Remote Access: " + (config.allowOthers() ? "Enabled" : "Disabled"));
        System.out.println("SSL: " + (config.useSSL() ? "Enabled" : "Disabled"));
        System.out.println("========================================");
        System.out.println("To connect to your database:");
        System.out.println("  JDBC URL: jdbc:h2:./workspace/iam");
        System.out.println("  Driver: org.h2.Driver");
        System.out.println("  User: sa");
        System.out.println("  Password: (empty)");
        System.out.println("========================================");
    }
    
    @Deactivate
    protected void deactivate() {
        if (webServer != null && webServer.isRunning(false)) {
            webServer.stop();
            System.out.println("H2 Web Console stopped");
            webServer = null;
        }
    }
    
    /**
     * Builds the command-line arguments for H2 Console server.
     */
    private String[] buildConsoleArgs(Config config) {
        java.util.List<String> args = new java.util.ArrayList<>();
        
        // Port
        args.add("-webPort");
        args.add(String.valueOf(config.port()));
        
        // Allow remote access
        if (config.allowOthers()) {
            args.add("-webAllowOthers");
        }
        
        // SSL
        if (config.useSSL()) {
            args.add("-webSSL");
        }
        
        // Don't open browser automatically in OSGi environment
        if (!config.openBrowser()) {
            args.add("-webDaemon");
        }
        
        return args.toArray(new String[0]);
    }
    
    /**
     * Gets the H2 Console URL.
     * 
     * @return the console URL or null if not running
     */
    public String getConsoleURL() {
        return webServer != null ? webServer.getURL() : null;
    }
    
    /**
     * Checks if the console is running.
     * 
     * @return true if console is running
     */
    public boolean isRunning() {
        return webServer != null && webServer.isRunning(false);
    }
}
Sie können das mit dem **Maven AntRun Plugin** oder dem **Maven Resources Plugin** machen. In Ihrer pom.xml verwenden Sie bereits das `maven-dependency-plugin` für ein ähnliches Ziel. Hier sind die besten Lösungen:

## Lösung 1: Maven AntRun Plugin (empfohlen für mehrere Ziele)

Fügen Sie dieses Plugin in Ihren `<build><plugins>` Bereich ein:

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-antrun-plugin</artifactId>
    <version>3.1.0</version>
    <executions>
        <execution>
            <id>deploy-jar</id>
            <phase>install</phase>
            <goals>
                <goal>run</goal>
            </goals>
            <configuration>
                <target>
                    <copy file="${project.build.directory}/${project.build.finalName}.jar" 
                          todir="C:/Pfad/zum/ersten/Ordner"/>
                    <copy file="${project.build.directory}/${project.build.finalName}.jar" 
                          todir="C:/Pfad/zum/zweiten/Ordner"/>
                </target>
            </configuration>
        </execution>
    </executions>
</plugin>
```

## Lösung 2: Ihr bestehendes dependency-plugin erweitern

Sie können Ihr vorhandenes `maven-dependency-plugin` (Zeilen 107-131) um weitere `<artifactItem>` erweitern:

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-dependency-plugin</artifactId>
    <version>3.6.0</version>
    <executions>
        <execution>
            <id>copy-artifact</id>
            <phase>install</phase>
            <goals>
                <goal>copy</goal>
            </goals>
            <configuration>
                <artifactItems>
                    <!-- Erster Ordner -->
                    <artifactItem>
                        <groupId>${project.groupId}</groupId>
                        <artifactId>${project.artifactId}</artifactId>
                        <version>${project.version}</version>
                        <outputDirectory>C:/IDE/WORKSPACE/CAR.OSGi/lib</outputDirectory>
                    </artifactItem>
                    <!-- Zweiter Ordner -->
                    <artifactItem>
                        <groupId>${project.groupId}</groupId>
                        <artifactId>${project.artifactId}</artifactId>
                        <version>${project.version}</version>
                        <outputDirectory>C:/Pfad/zum/zweiten/Ordner</outputDirectory>
                    </artifactItem>
                    <!-- Dritter Ordner -->
                    <artifactItem>
                        <groupId>${project.groupId}</groupId>
                        <artifactId>${project.artifactId}</artifactId>
                        <version>${project.version}</version>
                        <outputDirectory>C:/Pfad/zum/dritten/Ordner</outputDirectory>
                    </artifactItem>
                </artifactItems>
            </configuration>
        </execution>
    </executions>
</plugin>
```

## Lösung 3: Properties verwenden (für Flexibilität)

Sie können die Pfade auch in den `<properties>` definieren:

```xml
<properties>
    <maven.compiler.release>17</maven.compiler.release>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <target.deploy.path1>C:/IDE/WORKSPACE/CAR.OSGi/lib</target.deploy.path1>
    <target.deploy.path2>C:/anderer/pfad</target.deploy.path2>
    <target.deploy.path3>C:/noch/ein/pfad</target.deploy.path3>
</properties>
```

Dann im AntRun Plugin:
```xml
<copy file="${project.build.directory}/${project.build.finalName}.jar" 
      todir="${target.deploy.path1}"/>
<copy file="${project.build.directory}/${project.build.finalName}.jar" 
      todir="${target.deploy.path2}"/>
<copy file="${project.build.directory}/${project.build.finalName}.jar" 
      todir="${target.deploy.path3}"/>
```

## Meine Empfehlung:

Für Ihren Fall würde ich **Lösung 2** empfehlen (dependency-plugin erweitern), da Sie es bereits verwenden und es konsistent mit Ihrer bestehenden Konfiguration ist.

Welche Lösung passt am besten zu Ihren Anforderungen?

Diese Warnung erscheint, weil Ihre Anwendung (oder eine ihrer Abhängigkeiten) **Incubator-Module** von Java verwendet. Das sind experimentelle Features, die noch nicht finalisiert sind.

## Was sind Incubator-Module?

- `jdk.incubator.vector` - Vector API für SIMD-Operationen
- `jdk.incubator.foreign` - Foreign Function & Memory API (wurde in Java 19+ zu Panama API)

## Lösungen:

### 1. Warnung unterdrücken (wenn gewollt)

Fügen Sie beim Start der JVM diese Option hinzu:

```bash
java --add-modules jdk.incubator.vector,jdk.incubator.foreign -jar ihr-app.jar
```

Oder in Eclipse unter **Run Configurations → Arguments → VM arguments**:
```
--add-modules jdk.incubator.vector,jdk.incubator.foreign
```

### 2. Herausfinden, welche Bibliothek die Module verwendet

Führen Sie aus:
```bash
java -Xlog:module=debug -jar ihr-app.jar
```

Das zeigt, welche Komponente die Incubator-Module lädt.

### 3. Abhängigkeiten aktualisieren

Oft verwenden **ältere Versionen** von Bibliotheken diese Module. Prüfen Sie Ihre Dependencies:

**Häufige Kandidaten:**
- **Netty** (ältere Versionen)
- **Apache Arrow**
- **Panama-basierte Libraries**

In Ihrer pom.xml haben Sie:
- Typesafe Config
- SLF4J / Logback

Diese sollten die Incubator-Module **nicht** verwenden. Wahrscheinlich kommt es von einer **transitiven Abhängigkeit** oder aus dem OSGi-Container.

### 4. Java Version prüfen

Sie verwenden Java 17. In neueren Java-Versionen (19+) wurden einige Incubator-Features finalisiert:
- `jdk.incubator.foreign` → wurde zu `java.lang.foreign` in Java 19+

### 5. Für Eclipse/OSGi spezifisch

Falls Sie ein OSGi-Framework verwenden, prüfen Sie die **Framework-Konfiguration** (`config.ini` oder Start-Parameter), ob dort Incubator-Module aktiviert sind.

## Ist die Warnung schlimm?

**Nein**, die Anwendung läuft trotzdem. Es ist nur eine Warnung, dass Sie experimentelle Features nutzen, die sich in zukünftigen Java-Versionen ändern könnten.

## Empfehlung:

1. Prüfen Sie mit `java -Xlog:module=debug`, welche Komponente die Module lädt
2. Aktualisieren Sie die entsprechende Bibliothek
3. Falls es aus dem OSGi-Container kommt, prüfen Sie dessen Konfiguration

Möchten Sie gemeinsam herausfinden, welche Komponente die Warnung verursacht?