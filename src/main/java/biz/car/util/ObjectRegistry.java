/* -------------------------------------------------------------------------- * Project: CAR - Common Application Runtime * -------------------------------------------------------------------------- * Use of this software is subject to license terms. All Rights Reserved.  * -------------------------------------------------------------------------- */package biz.car.util;import java.util.HashMap;import java.util.Iterator;import java.util.Objects;import biz.car.SYS;import biz.car.XRuntimeException;import biz.car.bundle.MSG;/** * A general purpose registry for objects.<br> * Once an object is registered it can be fetched from the registry via the * object's id used when the object was registered. The registry cannot contain * duplicate entries. All entries are of the same type. *  * @version 2.0.0 08.01.2026 08:32:08 */public class ObjectRegistry<T extends Object> {	private HashMap<String, T> myMap;	/**	 * Creates a default <code>ObjectRegistry</code> instance.	 */	public ObjectRegistry() {		super();		myMap = new HashMap<String, T>();	}	/**	 * Removes all mappings from this map.	 */	public void clear() {		synchronized (myMap) {			myMap.clear();		}	}	/**	 * Returns <tt>true</tt> if this registry contains a mapping for the specified	 * object.	 * 	 * @param anId The id of the object whose presence in this registry is to be	 *             tested	 * @return <tt>true</tt> if this registry contains a mapping for the specified	 *         key.	 */	public boolean contains(String anId) {		synchronized (myMap) {			return myMap.containsKey(anId);		}	}	/**	 * Retrieves an entry from the registry.<br>	 * If the entry does not yet exist in this registry, then	 * <ul>	 * <li>the key is taken as a key for a class in <code>ClassUtil.Registry</code>	 * <li>a new instance of the found class is created	 * <li>the object instance is stored in this object registry	 * </ul>	 * 	 * @param aKey the key of the entry to fetch	 * @return the object found for the given key	 * @throws XRuntimeException if no entry was found and a new instance could not	 *                           be created	 */	public T forName(String aKey) {		synchronized (myMap) {			T l_ret = myMap.get(aKey);			if (l_ret == null) {				Class<?> l_class = ClassUtil.Registry.get(aKey);				if (l_class != null) {					l_ret = ClassUtil.newInstance(l_class);					myMap.put(aKey, l_ret);					return l_ret;				}				throw SYS.LOG.exception(MSG.RESOURCE_NOT_FOUND, aKey);			}			return l_ret;		}	}	/**	 * Retrieves an entry from the registry.	 * 	 * @param aKey the key of the entry to fetch	 * @return the object found for the given key or <code>null</code> if no entry	 *         could be found for the given key.	 */	public T get(String aKey) {		synchronized (myMap) {			return myMap.get(aKey);		}	}	/**	 * Returns an iterator over the keys in this registry. There are no guarantees	 * concerning the order in which the entries are returned.	 * 	 * @return an <tt>Iterator</tt> over the object keys in this registry	 */	public Iterator<String> keys() {		return myMap.keySet().iterator();	}	/**	 * Makes the given object to an entry in this registry.	 * 	 * @param anEntry the object to register	 * @return <code>true</code> if the object was registered, <code>false</code> if	 *         an object with the same id is already registered.	 * @throws NullPointerException if anEntry is <code>null</code>	 */	@SuppressWarnings("unchecked")	public void register(Identifiable anEntry) {		synchronized (myMap) {			register(anEntry.getId(), (T) anEntry);		}	}	/**	 * Makes the given object to an entry in this registry. If <code>anEntry</code>	 * is <code>null</code> then the given id will also be registerd with the	 * <code>null</code> value. This is useful to reserve an id as a placeholder.	 * The real object can then be registered with the same id.	 * 	 * @param anId    the id of the entry	 * @param anEntry the object to register	 * @return <code>true</code> if the object was registered, <code>false</code> if	 *         an object not equal <code>null</code> with the same id is already	 *         registered.	 * @throws NullPointerException if anId is <code>null</code>	 */	public void register(String anId, T anEntry) {		Objects.requireNonNull(anId);		synchronized (myMap) {			T l_tmp = myMap.get(anId);			if (l_tmp == null) {				myMap.put(anId, anEntry);				return;			}			throw SYS.LOG.exception(MSG.OBJECT_NOT_REGISTERED, anEntry.getClass(), anId);		}	}	/**	 * @return the number of entries in this registry	 */	public int size() {		synchronized (myMap) {			return myMap.size();		}	}	/**	 * Removes the given object from this registry.	 * 	 * @param anId the id of the object to unregister	 * @return <code>true</code> if the object was unregistered, <code>false</code>	 *         if the object was not registered.	 * @throws NullPointerException if anId is <code>null</code>	 */	public boolean unregister(String anId) {		Objects.requireNonNull(anId);		synchronized (myMap) {			T l_tmp = myMap.remove(anId);			boolean l_ret = l_tmp == null ? false : true;			if (l_ret) {				SYS.LOG.warn(MSG.OBJECT_UNREGISTERED, l_tmp.getClass().getName(), anId);			}			return l_ret;		}	}}