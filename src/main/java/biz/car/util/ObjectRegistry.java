/* -------------------------------------------------------------------------- * Project: CAR - Common Application Runtime * -------------------------------------------------------------------------- * Use of this software is subject to license terms. All Rights Reserved.  * -------------------------------------------------------------------------- */package biz.car.util;import java.util.HashMap;import java.util.Iterator;/** * A general purpose registry for objects.<br> * Once an object is registered it can be fetched from the registry via the * object's id used when the object was registered. The registry cannot contain * duplicate entries. All entries are of the same type. *  * @version 1.0.0 16.10.2024 15:22:42 */public class ObjectRegistry<T extends Object> {	private HashMap<String, T> myMap;	/**	 * Creates a default <code>ObjectRegistry</code> instance.	 */	public ObjectRegistry() {		super();		myMap = new HashMap<String, T>();	}	/**	 * Removes all mappings from this map.	 */	public void clear() {		synchronized (myMap) {			myMap.clear();		}	}	/**	 * Returns <tt>true</tt> if this registry contains a mapping for the	 * specified object.	 * 	 * @param anId The id of the object whose presence in this registry is to be	 *             tested	 * @return <tt>true</tt> if this registry contains a mapping for the	 *         specified key.	 */	public boolean contains(String anId) {		synchronized (myMap) {			return myMap.containsKey(anId);		}	}	/**	 * Retrieves an entry from the registry.	 * 	 * @param aKey the key of the entry to fetch	 * @return the object found for the given key or <code>null</code> if no	 *         entry could be found for the given key.	 */	public T get(String aKey) {		synchronized (myMap) {			return myMap.get(aKey);		}	}	/**	 * Returns an iterator over the keys in this registry. There are no	 * guarantees concerning the order in which the entries are returned.	 * 	 * @return an <tt>Iterator</tt> over the object keys in this registry	 */	public Iterator<String> keys() {		return myMap.keySet().iterator();	}	/**	 * Makes the given object to an entry in this registry.	 * 	 * @param anEntry	 *            the object to register	 * @return <code>true</code> if the object was registered,	 *         <code>false</code> if an object with the same id is already	 *         registered.	 * @throws NullPointerException	 *             if anEntry is <code>null</code>	 */	@SuppressWarnings("unchecked")	public boolean register(Identifiable anEntry) {		synchronized (myMap) {			return register(anEntry.getId(), (T) anEntry);		}	}	/**	 * Makes the given object to an entry in this registry. If	 * <code>anEntry</code> is <code>null</code> then the given id will also be	 * registerd with the <code>null</code> value. This is useful to reserve an	 * id as a placeholder. The real object can then be registered with the same	 * id.	 * 	 * @param anId    the id of the entry	 * @param anEntry the object to register	 * @return <code>true</code> if the object was registered,	 *         <code>false</code> if an object not equal <code>null</code> with	 *         the same id is already registered.	 * @throws NullPointerException if anId is <code>null</code>	 */	public boolean register(String anId, T anEntry) {		synchronized (myMap) {			if (anId != null) {				T l_tmp = myMap.get(anId);				if (l_tmp == null) {					myMap.put(anId, anEntry);					return true;				}				return false;			}			throw new NullPointerException();		}	}	/**	 * @return the number of entries in this registry	 */	public int size() {		synchronized (myMap) {			return myMap.size();		}	}	/**	 * Removes the given object from this registry.	 * 	 * @param anId the id of the object to unregister	 * @return <code>true</code> if the object was unregistered,	 *         <code>false</code> if the object was not registered.	 * @throws NullPointerException if anId is <code>null</code>	 */	public boolean unregister(String anId) {		synchronized (myMap) {			if (anId == null) {				throw new NullPointerException();			}			T l_tmp = myMap.remove(anId);			boolean l_ret = l_tmp == null ? false : true;			return l_ret;		}	}}